// Game state
let selectedPackage = null;
let triesLeft = 0;
let tokensFound = 0;
let squaresData = []; // 'token' or 'bomb'
let gameOver = false;

// Setup packages click
packages.forEach(pkg => {
  pkg.addEventListener('click', () => {
    packages.forEach(p => p.classList.remove('selected'));
    pkg.classList.add('selected');
    selectedPackage = {
      name: pkg.dataset.package,
      price: parseFloat(pkg.dataset.price),
      tokensRequired: parseInt(pkg.dataset.tokens),
      triesAllowed: parseInt(pkg.dataset.tries)
    };
    resetGame();
  });
});

// Reset & start game
function resetGame() {
  tokensFound = 0;
  triesLeft = selectedPackage.triesAllowed;
  gameOver = false;
  updateBalanceDisplay();
  cashoutBtn.disabled = true;
  generateGrid();
}

// Generate grid
function generateGrid() {
  grid.innerHTML = '';
  squaresData = [];

  // Fill with tokens and bombs
  let tokenPositions = [];
  while (tokenPositions.length < selectedPackage.tokensRequired) {
    let pos = Math.floor(Math.random() * 20);
    if (!tokenPositions.includes(pos)) tokenPositions.push(pos);
  }

  for (let i = 0; i < 20; i++) {
    squaresData[i] = tokenPositions.includes(i) ? 'token' : 'bomb';
  }

  // Create squares
  for (let i = 0; i < 20; i++) {
    const sq = document.createElement('div');
    sq.classList.add('square');
    sq.dataset.index = i;
    sq.addEventListener('click', () => clickSquare(i));
    grid.appendChild(sq);
  }
}

// Update balance display
function updateBalanceDisplay() {
  const cashoutVal = tokensFound >= selectedPackage.tokensRequired ? (selectedPackage.price * 2).toFixed(2) : '0.00';
  balanceDisplay.textContent = `Tokens Found: ${tokensFound} | Tries Left: ${triesLeft} | Cashout: $${cashoutVal}`;
}

// Handle square click
function clickSquare(i) {
  if (!selectedPackage) {
    alert('Please select a package first.');
    return;
  }
  if (gameOver) return; // Prevent clicks after game end

  const sq = grid.children[i];
  if (sq.classList.contains('revealed')) return; // already clicked

  sq.classList.add('revealed');
  triesLeft--;
  updateBalanceDisplay();

  if (squaresData[i] === 'token') {
    sq.textContent = 'ðŸ’°';
    tokensFound++;
    updateBalanceDisplay();

    if (tokensFound >= selectedPackage.tokensRequired) {
      cashoutBtn.disabled = false;
      alert(`Congrats! You found all tokens and can cash out $${(selectedPackage.price * 2).toFixed(2)}!`);
      gameOver = true;
      disableGrid();
      return;
    }
  } else {
    sq.textContent = 'ðŸ’€';
    alert('Boom! You hit a bomb. Game over and balance reset.');
    gameOver = true;
    disableGrid();
    resetGame();
    return;
  }

  if (triesLeft === 0 && !gameOver) {
    alert('No tries left. You did not find all tokens. Game over.');
    gameOver = true;
    disableGrid();
    resetGame();
    return;
  }
}

// Disable all squares after game ends
function disableGrid() {
  for (let sq of grid.children) {
    sq.style.cursor = 'default';
    sq.replaceWith(sq.cloneNode(true)); // Removes all event listeners by replacing element
  }
}

// Cashout button
cashoutBtn.addEventListener('click', () => {
  alert(`Cashing out $${(selectedPackage.price * 2).toFixed(2)}! Thank you for playing!`);
  resetGame();
});
